<!DOCTYPE html>
<html>
  <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>bare metal af - A State Machine Of State Machines</title>
      <meta name="viewport" content="width=device-width">

      <!-- syntax highlighting CSS -->
      <link rel="stylesheet" href="/css/syntax.css">

      <!-- Custom CSS -->
      <link rel="stylesheet" href="/css/main.css">

      <!-- Responsive CSS -->
      <link rel="stylesheet" href="/css/responsive.css">

      <!-- Google Fonts -->
      <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700' rel='stylesheet' type='text/css'>
      <link href='http://fonts.googleapis.com/css?family=Raleway:300,400,700' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <div class="site">
      <div class="sidebar" id="sidebar">
        <div class="header">
          <h1 class="title"><a href="/"><img id="logo" src="/images/profile_picture.png"></a></h1>
          <span class="tagline">Bare Metal 0xaf</span>
        </div>
        <div class="posts">
          <ul class="posts-list">
            
            
            
            
              <li class="post-link">
                <a class="post-title" href="/embedded/systems/2022/05/15/my-embedded-must-haves-at-home.html">
                  <span class="post-date">15 May 2022</span>
                  My Embedded must haves at home
                </a>
              </li>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </ul>
        </div>
        <div class="footer">
          <span id="footer-links">
            <a href="/about/2022/05/16/about.html" class="footer-link">About</a> <span class="separator">&bull;</span>
            <!--<a href="https://twitter.com/pdxwrh2" class="footer-link">Twitter</a> <span class="separator">&bull;</span>-->
            <a href="https://github.com/wrh2" class="footer-link">GitHub</a> <span class="separator">&bull;</span>
            <a href="https://www.linkedin.com/in/will-h-b2682319b" class="footer-link">LinkedIn</a>
          </span>
        </div>
      </div>

        <div class="content" id="home">
  <div id="sidebar-button">
    <img src="/images/sidebar-button.png">
  </div>
  <div id="post-info">
    <div id="cover-photo-container">
      <img id="cover-photo" src="">
    </div>
    <div id="info-container">
      <h1 id="title">A State Machine Of State Machines</h1>
      <!--<span id="date">17 Mar 2019</span>-->
    </div>
  </div>

  <div class="post">
    <h1 id="introduction">Introduction</h1>

<p>Writing a more technical article without much explanation to expedite publishing some material. Going to tackle Finite State Machine programming techniques in C because it’s something I do a lot of when developing firmware for an embedded system.</p>

<h1 id="designing-a-state-machine-of-state-machines">Designing a state machine of state machines</h1>

<h2 id="while1">while(1)</h2>

<p>Every C program starts here.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//example main entry point
int main(void){

    while(1){

        //stuff happens here

    }

    return 0; //should never get here

}
</code></pre></div></div>

<h2 id="hardware-tasks">Hardware tasks</h2>

<p>Assume you have a single core processor as such is often the case with an embedded system. We want to operate more than 1 thing with our processor at a time, but we can’t really because its a single process running on a single processor so what we can do is break up that which we seek to achieve. You do this by spending a little bit of time doing each thing that we want to do.</p>

<p>Let’s assume we had 3 peripherals that need to be driven so we create a function for those tasks</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void hardwareTasks(void){

    i2cTasks();

    spiTasks();

    uartTasks();

    //whatever other tasks you want to do here

}
</code></pre></div></div>

<p>Each function in there is part of an API for the peripheral driver where each time it is called it will do something based upon it’s current state and any input (e.g. hardware interrupts)</p>

<p>This is an example of a <a href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy state machine</a>. Here’s an example of one in C.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef enum{
    I2C_STATE0, /* Initial state */
    I2C_STATE1,
//..I2C_STATEn,
}i2c_states_t;

typedef struct{
    i2c_states_t state;
    i2c_states_t last_state; //not necessary but nice for debugging
}i2c_driver_t;

i2c_driver_t i2c_driver = {0};

void i2cTasks(void)
{
    
    //make decision based on state
    switch(i2c_driver.state)
    {

        // initial state
        case I2C_STATE0:
        {


            // check our input
            if(some_hw_interrupt_bit_is_set)
            {

                // do something based on that here

                // state update
                i2c_driver.last_state = i2c_driver.state;
                i2c_driver.state = I2C_STATE1;

            }

            break;

        }

        case I2C_STATE1:
        {

            // check input 
            if(some_other_hw_interrupt_bit_is_now_set)
            {

                // do something based on that here

                // state update
                i2c_driver.last_state = i2c_driver.state;
                i2c_driver.state = I2C_STATE2;

            }  

            break;

        }

        /*
        case I2C_STATEn:
        {
            //so on and so on
            break;
        }
        */

        // unhandled state
        default:
        {

            //whoops, deal with and record error
            break;

        }

    }

}
</code></pre></div></div>

<p>What happens now is that each time these functions are called some amount of time will be spent dealing with the current state and then changing the state given the current input. The goal here is to get in and get out so we can move on to the next thing that needs to be done. Ideally, you never spend more than some amount of microseconds in your function.</p>

<p>We probably want to achieve something other than just running the hardware. Now we can create another state machine that takes care of higher level stuff, often referred to as the application layer.
Our main function now looks like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(void){

    while(1){

        hardwareTasks();

        applicationTasks();

    }

    return 0; //should never get here

}
</code></pre></div></div>

<p>This looks exactly like what you would assume from the above peripheral driver example. However, states in the application layer usually take time as one of their inputs. A semblance of time is provided by a system timer that generates an interrupt. The period of that interrupt can be used to count how many times it has been called and from that you can extract how much time has elapsed. For a full blown operating system, this is called a kernel tick. An operating system usually makes a context switch based on this (e.g. switch to another thread)
but for this example it just changes the state of the state machine since we just have one process. For this example, lets have a state for things that happen every 1 millisecond and things that happen every 100 milliseconds.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef enum{
    APP_STATE_IDLE, /* Initial state */
    APP_STATE_1MS,
    APP_STATE_100MS,
//..APP_STATEn,
}app_states_t;

typedef struct{
    app_states_t state;
    app_states_t last_state; //not necessary but nice for debugging
}app_driver_t;

app_driver_t app_driver = {0};

void applicationTasks(void)
{
    
    //make decision based on state
    switch(app_driver.state)
    {

        // initial state
        case APP_STATE_IDLE:
        {

            // no need to do anything
            break;

        }

        case APP_STATE_1MS:
        {

            // do something here

            break;

        }

        case APP_STATE_100MS:
        {

            // do something here            

            break;
        }

        // unhandled state
        default:
        {

            // whoops, deal with and record error
            break;

        }

    }

}
</code></pre></div></div>

<p>But wait there’s more! There are usually external devices that you are using with the peripherals. For example, you could have an accelerometer
that is being interfaced via i2c. So your driver for i2c will have an API that will allow another driver, such as one you would
 have for an accelerometer, to read or write to that device. The driver you would write for an accelerometer is an example of middleware.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(void){

    while(1){

        hardwareTasks();

        middlewareTasks();

        applicationTasks();

    }

    return 0; //should never get here

}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void middlewareTasks(void){

    accelerometerTasks();
    // other middleware tasks

}
</code></pre></div></div>

<p>Let’s piece that together with the application. Assume there is an API for the accelerometer.
Something like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef enum{

        PENDING,
        COMPLETE,
        FAILURE,
        //etc...

}transfer_status_t;

bool accelerometerRead(uint8_t * buffer); //reads just the acceleration data

void accelerometerTasks(void); // services the FSM

transfer_status_t accelerometerTransferStatus(void); // tells you whether the transfer is done or not
</code></pre></div></div>

<p>For this example, we’ll request the accelerometer be read every 1 ms.
You might go a step further and create a buffer of some number of samples from the accelerometer than print it out via UART.
Or perhaps log it to an SD card via SPI. You might also collect your tasks and organize them with a data structure like a stack.
Pop off the stack every increment and handle that task. This is a primitive form of scheduling.</p>

<p>I won’t fill in all the blanks but it would look something like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef enum{
    READ_ACC,
    READ_ACC_WAIT,
}task_type_t;

typedef union{

    uint64_t data64;

    uint32_t data32[2];

    uint16_t data16[4];

    uint8_t data8[8];

}task_data_t;


typedef struct{

    task_type_t type;

    task_data_t data

}task_t;


void applicationTaskHandler1ms(task_t task){

    switch(task.type){


        case READ_ACC:
        {

                // ask the driver to perform a read
                // success is based on whether or not the i2c bus is busy
                // but those details are buried in the drivers
                if(accelerometerRead(&amp;my_buffer)){

                        //
                        // this function pushes a task on to the stack
                        push_task(READ_ACC_WAIT, 0); //not passing any data


                }
                else push_task(READ_ACC, task.data); //failed, try again

                break;

        }
        
        case READ_ACC_WAIT:
        {

                // ask the driver if we are done
                if(accelerometerTransferStatus() == COMPLETE){
                    
                    // contents now in buffer

                }
                else push_task(READ_ACC_WAIT, task.data); //not finished, see if its done next time around

                break;

        }


    }

}

void applicationTasks(void)
{
    
    //make decision based on state
    switch(app_driver.state)
    {

        // initial state
        case APP_STATE_IDLE:
        {

            //no need to do anything
            break;

        }

        case APP_STATE_1MS:
        {

            // task handler
            applicationTaskHandler1ms(pop_task(&amp;my_1ms_task_stack));

            // state update
            app_driver.last_state = state;
            app_driver.state = APP_STATE_IDLE;

            break;

        }

        case APP_STATE_100MS:
        {

            // task handler
            applicationTaskHandler100ms(pop_task(&amp;my_100ms_task_stack));

            // state update
            app_driver.last_state = state;
            app_driver.state = APP_STATE_IDLE;

            break;

        }

        // unhandled state
        default:
        {

            //whoops, deal with and record error
            break;

        }

    }

}
</code></pre></div></div>

<h2 id="other-ways-to-do-it">Other ways to do it</h2>

<p>Now that I’ve got the foundation laid here, the real reason I wrote this is to talk about the ways in which finite state machines are implemented.</p>

<p>###</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

struct fsm;
typedef void state_fn(struct fsm *);

struct fsm{
    state_fn * next;
    int i; //data
};

state_fn foo, bar;

void foo(struct fsm * state){
    printf("%s %i\n", __func__, ++state-&gt;i);
    state-&gt;next = bar;
}

void bar(struct fsm * state){
    printf("%s %i\n", __func__, ++state-&gt;i);
    state-&gt;next = state-&gt;i &lt; 10 ? foo : 0;
}

int main(void){
    struct fsm state = {foo, 0};
    while(state.next) state.next(&amp;state);
    return 0;
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * Example of implementing FSM with function pointers as opposed to switch case statements
 * Programmed by William Harrington
 * Adapted from this stackoverflow answer: https://stackoverflow.com/a/1383453
 */

#include &lt;stdio.h&gt;

/* this will be used to define the structure for each state */
/* but we need to define it after we define the template */
/* for the function pointer */
struct state;

/* template for our function pointers */
typedef void stateFunction(struct state *);

typedef struct state{

    /* pointer to the last state function called */
    stateFunction * last;

    /* pointer to the next state function */
    stateFunction * next;

    /* data that we use for determining state transitions */
    int i;

}state;

/* these are our "states" */
stateFunction idle, begin, wait, finish;

/* idle state */
void idle(state * ptr){

    /* prints out the name of the function we are currently in */
    printf("%s\n", __func__);

    /* keep track of last state */
    ptr-&gt;last = idle;

    /* transition to begin state */
    if(ptr-&gt;i == 1) ptr-&gt;next = begin;

    /* this will make our main function return */
    else if(ptr-&gt;i == 10) ptr-&gt;next = 0;

    /* stay in idle state */
    else ptr-&gt;next = idle;

}

/* begin state */
void begin(state * ptr){

    /* prints out the name of the function we are currently in */
    printf("%s\n", __func__);

    /* state transition */
    ptr-&gt;last = begin;
    ptr-&gt;next = wait;

}

void wait(state * ptr){

    /* prints out the name of the function we are currently in */
    printf("%s\n", __func__);

    /* state transition */
    ptr-&gt;last = wait;
    ptr-&gt;next = finish;

}

void finish(state * ptr){

    /* prints out the name of the function we are currently in */
    printf("%s\n", __func__);

    /* state transition */
    ptr-&gt;last = finish;
    ptr-&gt;next = idle;

    /* this will cause the program to end */
    ptr-&gt;i = 10;

}

int main(void){

    /* initialize FSM */
    state fsm = {idle, idle, 1};

    /* will execute until fsm.i == 10, then fsm.next will become NULL and the while loop will terminate than main will return */
    while(fsm.next) fsm.next(&amp;fsm);

    return 0;

}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

/* states */
typedef enum{
    IDLE,
    BEGIN,
    WAIT,
    FINISH,
    END,
}state_t;

/* structure for fsm object */
typedef struct{
    state_t state;
    void (*func)(void);
}fsm_t;

/* prototypes for state functions */
void idleState(void);
void beginState(void);
void waitState(void);
void finishState(void);

/* lookup table for state machine */
fsm_t lut[] = 
{ 
    {IDLE, idleState},
    {BEGIN, beginState},
    {WAIT, waitState},
    {FINISH, finishState},
    {END, 0} //this state will cause our while loop in main to break
};

/* controls where you go in the lookup table */
state_t current_state = IDLE;

void idleState(void){
    printf("%s\n", __func__);
    current_state = BEGIN;
}

void beginState(void){
    printf("%s\n", __func__);
    current_state = WAIT;
}

void waitState(void){
    printf("%s\n", __func__);
    current_state = FINISH;
}

void finishState(void){
    printf("%s\n", __func__);
    current_state = END;
}

int main(void){

    while(lut[current_state].func) (*lut[current_state].func)();

    return 0;

}
</code></pre></div></div>

  </div>
  <div class="colophon">
    <p>
      <span id="pub-date">Published on 17 Mar 2019</span> <!--<span class="separator">&bull;</span>-->
      <!--<span id="social">Find me on <a href="https://twitter.com/pdxwrh2">LinkedIn</a>!</span>-->
    </p>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript" ></script>
  </div>
</div>



    </div>
    <script src="/scripts/responsive.js" type="text/javascript"></script>
  </body>
</html>
